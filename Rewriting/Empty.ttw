// The `Empty` type is built-in.

// We will use `abort` as the eliminator.
abort : Empty -> A

// `Empty` is a strict proposition.
StrictProp-Empty (e1 e2 : Empty) : e1 = e2 := refl

// `Empty` lives in the lowest predicative universe and at h-level 1
// (i.e. in the universe of strict propositions).
> :check Empty
> Empty : Type (h = 1, p = 0)

// `Empty` enjoys some special computational properties at the type level to
// make our lives easier, together with the corresponding properties for terms.
Sum-Empty-l : Empty + A = A := refl
Sum-Empty-l' (a : A) : (inr a : Empty + A) = a := refl

Sum-Empty-r : A + Empty = A := refl
Sum-Empty-r' (a : A) : (inl a : A + Empty) = a := refl

Prod-Empty-l : Empty * A = Empty := refl
Prod-Empty-l' (e : Empty) (a : A) : (e, a) = e := refl

Prod-Empty-r : A * Empty = Empty := refl
Prod-Empty-r' (e : Empty) (a : A) : (a, e) = e := refl

// These properties generalize to records.
// TODO: stating this property requires extensible records, which are experimental.
Record-Empty (R : RType) : (e : Empty & R) = Empty := refl

// These are not the only special computational properties of `Empty` - there's more:
Fun-Empty : Empty -> A = Unit := refl
Fun-Empty' (f : Empty -> A) : f = unit := refl

Path-Empty : (Empty = Empty) = Unit := refl

Nabla-Empty : (∇ α : A. Empty) = Empty := refl

Sub-Empty : Sub Empty = Unit := refl
Sub-Empty' (X : Sub Empty) (x : X) : x = unit := refl

Ref-Empty (P : Empty -> Prop) : {e : Empty | P e} = Empty := refl