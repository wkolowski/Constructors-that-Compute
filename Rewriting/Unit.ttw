// The `Unit` type is built-in.

// Its only term is called `unit`.
unit : Unit

// `Unit` is a strict proposition.
StrictProp-Unit (u1 u2 : Unit) : u1 = u2 := refl

// `Unit` lives in the lowest predicative universe and at h-level 0
// (i.e. in the universe of contractible types).
> :check Unit
> Unit : Type (h = 0, p = 0)

// `Unit` enjoys some special computational properties at the type level to
// make our lives easier.
Prod-Unit-l : Unit * A = A := refl
Prod-Unit-l' (u : Unit) (a : A) : (u, a) = a := refl

Prod-Unit-r : A * Unit = A := refl
Prod-Unit-r' (a : A) (u : Unit) : (a, u) = a := refl

// These properties generalize to records.
// TODO: stating this property requires extensible records, which are experimental.
Record-Unit-r (R : RType) : (u : Unit & R) = R := refl

// These are not the only special computational properties of `Unit` - there's more:
Fun-Unit-Dom : Unit -> A = A := refl
Fun-Unit-Dom' (f : Unit -> A) : f = f unit := refl

Fun-Unit-Cod : A -> Unit = Unit := refl
Fun-Unit-Cod' (f : A -> Unit) : f = unit := refl

Path-Unit : (Unit = Unit) = Unit := refl

Nabla-Unit : (∇ α : A. Unit) = Unit := refl

//Sub-Unit : Sub Unit = Bool := refl

Ref-Unit (P : Unit -> Prop) : {u : Unit | P u} = Unit := refl