// The standard definition of addition is structurally recursive on the first
// argument, which means that we get computation rules like `add z l => l` and
// so on. But we need to manually prove that `add k z => k` etc. because even
// when the second argument is known, there's no computation.

add : Z -> Z -> Z :=
| z     l      => l
| (s k) l      => s (add k l)
| (p k) l      => p (add k l)
| k     z      => k
| k     (s l') => s (add k l')
| k     (p l') => p (add k l')

// Let's make our lives easier with overlapping patterns. See
// https://jesper.sikanda.be/files/overlapping-and-order-independent-patterns.pdf
// for an explanation of what exactly we're doing here.

// In short: in the new definition of `add`, we get three more pattern matching
// clauses, which make `add k z` compute to `k` and similarly for `s` and `p`.
// This is INSANELY comfortable and allows us to easily prove theorems which
// otherwise are much more annoying, but ultimately easy, like commutativity of
// addition.

add-comm : (k l : Z) -> add k l = add l k :=
| z      l => refl
| (s k') l => ap s (add-comm k' l)
| (p k') l => ap p (add-comm k' l)

sub : Z -> Z -> Z :=
| k      z       => k
| k      (s l') => p (sub k l')
| k      (p l') => s (sub k l')
| (s k') l      => s (sub k' l)
| (p k') l      => p (sub l' l)

// We can also have more computation rules for subtraction. Note, however, that
// we don't want to compute `sub z l`, because it would need to compute to
// `neg l` and this would probably be awkward in some situations... although
// this is just my speculation.

sub-diag : (k : Z) -> sub k k = z :=
| z    => refl
| s k' => sub-diag k'
| p k' => sub-diag k'

// With these bonus computation rules, proving that k - k = 0 is extremely
// easy. You don't want to know how much harder it would be without them...

// For `z`, `refl` suffices. For `s k'`, we have

// LHS: `sub (s k') (s k') => p (sub (S k') k') => p (s (sub k' k')) =>
//       sub k' k'`
// RHS: `z`

// so it suffices to use the induction hypothesis. The case of `p k'` is
// analogous.

sub-add : (k l m : Z) -> sub k (add l m) = sub (sub k l) m :=
| k z      m => refl
| k (s l') m => ap p (sub-add k l' m) 
| k (p l') m => ap s (sub-add k l' m)

// LHS: `sub k (add (s l') m) => sub k (s (add l' m)) => p (sub k (add l' m))`
// RHS: `sub (sub k (s l')) m => sub (p (sub k l')) m => p (sub (sub k l') m)`

// LHS: `sub k (add (p l') m) => sub k (p (add l' m)) => s (sub k (add l' m))`
// RHS: `sub (sub k (p l')) m => sub (s (sub k l')) m => s (sub (sub k l') m)`
