\documentclass[11pt]{article}

\usepackage{amsthm, amssymb}
\theoremstyle{definition}
\newtheorem{definition}{Definition}[section]
\newtheorem{theorem}{Theorem}[section]

% Technical.
\renewcommand{\phi}{\varphi}
\newcommand{\txt}[1]{\texttt{#1}}
\newcommand{\text}[1]{\texttt{#1}}
\renewcommand{\(}{\left(}
\renewcommand{\)}{\right)}

% Definitions.
\newcommand{\defn}{:\equiv}
\newcommand{\defp}{:=}

% Universes.
\newcommand{\U}{\mathcal{U}}

\newcommand{\isContr}{\text{isContr}}
\newcommand{\isProp}{\text{isProp}}
\newcommand{\isSet}{\text{isSet}}
\newcommand{\isGrpd}{\text{isGrpd}}

\newcommand{\Contr}{\text{Contr}}
\newcommand{\Prop}{\text{Prop}}
\newcommand{\Set}{\text{Set}}
\newcommand{\Grpd}{\text{Grpd}}
%\newcommand{\Type}{\text{Type}}

% Functions.
\newcommand{\lam}[2]{\lambda #1.#2}
\newcommand{\apl}[2]{#1\ #2}

\newcommand{\id}{\text{id}}
\newcommand{\comp}{\circ}
\newcommand{\finv}[1]{#1^{-1}}

% Paths.
\newcommand{\eq}[2]{#1 = #2}
%\newcommand{\refl}[1]{\text{refl}_{#1}}
\newcommand{\refl}{\txt{refl}}

\newcommand{\inv}[1]{#1^{-1}}
\newcommand{\sq}{\mathbin{\vcenter{\hbox{\rule{.3ex}{.3ex}}}}}

% Equivalence.
\newcommand{\hequiv}[2]{#1 \simeq #2}

% Path application and transport.
\newcommand{\ap}[2]{\text{ap}_{#1}(#2)}
\newcommand{\apd}[2]{\text{apd}_{#1}(#2)}
\newcommand{\transport}{\text{transport}}

\newcommand{\qinv}{\text{qinv}}
\newcommand{\isequiv}{\text{isequiv}}

% Basic types.
\newcommand{\Empty}{\mathbf{0}}
\newcommand{\Unit}{\mathbf{1}}

\newcommand{\Bool}{\mathbf{2}}
\newcommand{\true}{\txt{tt}}
\newcommand{\false}{\txt{ff}}

\newcommand{\Nat}{\mathbb{N}}
\newcommand{\ZZ}{\mathbb{Z}}
\newcommand{\Conat}{\mathbb{N}_\infty}
\newcommand{\dprod}[2]{\prod #1.#2}
\newcommand{\dsum}[2]{\sum #1.#2}

% Products.
\newcommand{\prodt}[2]{#1 \times #2}
\newcommand{\pair}[2]{(#1, #2)}
\newcommand{\outl}{\text{pr}_1}
\newcommand{\outr}{\text{pr}_2}

% Sums
\newcommand{\sumt}[2]{#1 + #2}
\newcommand{\inl}{\txt{inl}}
\newcommand{\inr}{\txt{inr}}

% Logic.
\newcommand{\all}[2]{\forall #1.#2}
\newcommand{\ex}[2]{\exists #1.#2}
\newcommand{\conj}[2]{#1 \land #2}
\newcommand{\disj}[2]{#1 \lor #2}
\newcommand{\True}{\top}
\newcommand{\False}{\bot}
\newcommand{\impl}[2]{#1 \implies #2}

% Rest.
\newcommand{\happly}{\text{happly}}
\newcommand{\funext}{\text{funext}}

\newcommand{\idtoeqv}{\text{idtoeqv}}
\newcommand{\ua}{\text{ua}}

\newcommand{\code}{\text{code}}
\newcommand{\encode}{\text{encode}}
\newcommand{\decode}{\text{decode}}

\newcommand{\hS}{\mathbb{S}^1}
\newcommand{\base}{\text{base}}
\newcommand{\looop}{\text{loop}}

\newcommand{\I}{\mathbb{I}}
\newcommand{\IZ}{0_\mathbb{I}}
\newcommand{\II}{1_\mathbb{I}}
\newcommand{\seg}{\text{seg}}

\newcommand{\trf}[1]{||#1||}
\newcommand{\tri}[1]{|#1|}

\title{My research on constructors that compute}
\date{13 May 2021}

\begin{document}

\maketitle

\section{Constructors that compute}

The idea is that constructors of inductive types can have an attached pattern matching clause which tells us how they compute. This can be used for many things, among them making quotients or securing nice normal forms for the type.

\begin{center}
The type of integers.

\begin{tabular}{l}
$\ZZ : \U \defn$ \\
$ |\ z : \ZZ$ \\
$ |\ s : \ZZ \to \ZZ\ \text{with}$ \\
\qquad $|\ \text{s (p k) => k}$ \\
$ |\ p : \ZZ \to \ZZ\ \text{with}$ \\
\qquad $|\ \text{p (s k) => k}$
\end{tabular}
\end{center}

\newcommand{\abs}{\txt{abs}}

\begin{center}
Absolute value.

\begin{tabular}{l}
$\abs : \ZZ \to \ZZ \defn$ \\
\txt{| z => z} \\
\txt{| s k => s k} \\
\txt{| p k => s (abs k)}
\end{tabular}
\end{center}

\begin{center}
\begin{tabular}{l}
\txt{abs-abs} $: \forall k : \ZZ, \abs\ (\abs\ k) = \abs\ k$ \\
\txt{| z => \refl} \\
\txt{| s k => \refl} \\
\txt{| p k => \refl}
\end{tabular}
\end{center}

\end{document}