// New idea: if we have constructors that compute and also induction-recursion,
// then we can define a universe with type constructors that compute! What's more,
// we can use this feature to make the path type compute instead of having to
// write all these damn path abstractions!

data U : Type :=
| 0  : U
| 1  : U
| +  : U -> U -> U
  | 0 + u => u
  | u + 0 => u
  | (u1 + u2) + u3 => u1 + (u2 + u3)
| *  : U -> U -> U
  | 0 * _ => 0
  | _ * 0 => 0
  | 1 * u => u
  | u * 1 => u
  | (u1 * u2) * u3 => u1 * (u2 * u3)
  | u1 * (u2 + u3) => (u1 * u2) + (u1 * u3)
  | (u1 + u2) * u3 => (u1 * u3) + (u2 * u3)
| -> : U -> U -> U
  | _ -> 1 => 1
  | 0 -> _ => 1
  | 1 -> u => u
  | (u1 * u2) -> u3 => u1 -> (u2 -> u3)
  | (u1 + u2) -> u3 => (u1 -> u3) * (u2 -> u3)
  | u1 -> (u2 * u3) => (u1 -> u2) * (u1 -> u3)
| pi (dom : U) (cod : ∇ α : V. El dom -> U)
  | 0, _ => 1
  | 1, _ => cod unit
  | u1 * u2, _ => pi u1 (fun x => pi u2 (fun y => cod (x, y)))
  | u1 + u2, _ => pi u1 (fun x => dom (inl x)) * pi u2 (fun y => dom (inr y))
//  | u1 -> (u2 * u3) => (u1 -> u2) * (u1 -> u3)
| eq : (u : U) (x y : El u) -> U
  | 0          _         _       => Unit
  | 1          _         _       => Unit
  | (u1 + u2)  (inl x') (inl y') => eq u1 x' y'
  | (u1 + u2)  (inr x') (inr y') => eq u2 x' y'
  | (u1 + u2)  _        _        => Empty
  | (u1 * u2)  (x1, y1) (x2, y2) => eq u1 x1 x2 * eq u2 y1 y2
  | (u1 -> u2) f        g        => // no forall

with
El : (u : U) -> Type :=
| 0        => Empty
| 1        => Unit
| u +  v   => El u + El v
| u *  v   => El u * El v
| u -> v   => El u -> El v
| pi u v   => (x : El u) -> El (v x)
| eq u x y => x = y