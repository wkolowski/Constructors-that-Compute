
data V : Type :=

data CBin (A V : Type) : Type
| E
| N (x : A) (l r : CBin A)
| Var (v : Name V)
| Fix (∇ α : V. CBin A)
  | ν α. E     => E
  | ν α. Var _ => E
  | ν α. Fix (t @ a) => Fix t

// Function template
| E       =>
| N x l r =>
| Var v   =>
| Fix t   =>

// Function template v2.
| E       =>
| N x l r =>
| Var v   =>
| Fix (ν α. N (x @ α) (l @ α) (r @ α)) =>

map (f : A -> B) : CBin A -> CBin B
| E       => E
| N x l r => N (f x) (map l) (map r)
| Var v   => Var v
| Fix t   => Fix (ν α. map (t @ α))

mirror : CBin A -> CBin A
| E       => E
| N x l r => N x (mirror r) (mirror l)
| Var v   => Var v
| Fix t   => Fix (ν α. mirror (t @ α))

any (p : A -> Bool) : CBin A -> Bool
| E       => ff
| N x l r => p x || any l || any r
| Var v   => ff
| Fix t   => anonymize (ν α. any (t @ α))

takeWhile (p : A -> Bool) : CBin A -> CBin A
| E       => E
| N x l r => if p x then N x (takeWhile l) (takeWhile r) else E
| Var v   => Var v
| Fix t   => Fix (ν α. takeWhile (t @ α))

any-mirror (p : A -> Bool) : (t : CBin A) -> any p (mirror t) = any p t
| E       => refl
| N x l r => fun i : I => p x || (||-comm (any-mirror p r i) (any-mirror p l i) i)
| Var v   => refl
| Fix t'  => fun i : I => anonymize (ν α. any-mirror p (t' @ α) i)

// LHS: any p (N x (mirror r) (mirror l)) => p x || any p (mirror r) || any p (mirror l)
// RHS: any p (N x l r) => p x || any p l || any p r

// LHS: any p (mirror (Fix t')) => any p (Fix (ν α. mirror (t' @ α))) => anonymize (ν α. αny p (mirror (t' @ α)))
// RHS: any (Fix t') => anonymize (ν α. any (t' @ α))

// Alternative proof of any-mirror's case N:
proof
  by rewrite ||-comm, (any-mirror r), (any-mirror l)
qed

spam (x : A) : CBin A :=
  Fix (ν α. N x (Var α) (Var α))

// TODO: in the second case, `x : ∇ α : V. A` and not just `x : A`, so it's a type error.
// This is probably incorrect.
recycle (a : A) : (∇ α : V. CBin A) -> CBin A
| ν α. E       => E
| ν α. N x l r => N x (ν α. recycle (l @ α)) (ν α. recycle (r @ α))
| ν α. Var α   => N a (Var α) (Var α)
| ν α. Var v   => Var v
| ν α. Fix t   => Fix (ν α. recycle (t @ α))

unN : CBin A -> Option (A * CBin A * CBin A)
| E       => None
| N x l r => Some (x, l, r)
| Var v   => None
| Fix (ν α. N (x @ α) (l @ α) (r @ α)) => Some (x, recycle x l, recycle x r)