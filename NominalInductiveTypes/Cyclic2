// A more explicit representation.
%ConstructorsThatCompute
data Cyclic (A V : Type) : Type
| Nil
| Cons (h : A) (t : Cyclic A V)
| Var  (v : Name V)
| Fix  (l : ∇ α : V. Cyclic A V)
  | ν α. Nil => Nil
  | ν α. Var α => Nil
  | ν α. Var v => Var v
  | ν α. Fix (l @ α) => Fix l

// Function template.
| Nil      =>
| Cons h t =>
| Var  v   =>
| Fix  l   =>

map (f : A -> B) : Cyclic A V -> Cyclic B V
| Nil      => Nil
| Cons h t => Cons (f h) (map f t)
| Var v    => Var v
| Fix l    => Fix (ν α. map f (l @ α))

app : (l1 l2 : Cyclic A V) -> Cyclic A V
| _       , Nil => l1
| Nil     , _   => l2
| Cons h t, _   => Cons h (app t l2)
| Var v   , _   => Var v
| Fix l1' , _   => Fix (ν α. app (l1 @ α) l2)

// We can easily implement bind, which is hard with the other representation.
bind (f : A -> Cyclic B V) : Cyclic A V -> Cyclic B V
| Nil      => Nil
| Cons h t => app (f h) (bind f t)
| Var v    => Var v
| Fix l    => Fix (ν α. bind f (l @ α))

// The same is true for filter, which is easy in this representation, but very hard with the first one.
filter (p : A -> Bool) : Cyclic A V -> Cyclic A V
| Nil      => Nil
| Cons h t => if p h then Cons h (filter t) else filter t
| Var  v   => Var v
| Fix  l   => Fix (ν α. filter (l @ α))

Import Cylic.Cyclic as C

f : Cyclic A V -> C A V
| Nil      => Nil
| Cons h t => RCons (f h) (ν _. map f t)
| Var v    => Var v
| Fix (ν α. Cons h t) => RCons h (ν α. f (t @ α))

g : C A V -> Cyclic A V
| Nil       => Nil
| RCons h t => Fix (ν α. Cons h (g (t @ α)))
| Var v     => Var v