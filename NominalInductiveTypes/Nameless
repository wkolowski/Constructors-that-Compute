// In this file we will do some research on nameless types in order to increase
// our knowledge of all this nominal magic.

unanonymize (x : A) : ∇ α : N. A := ν α. x

// A type is nameless when its values can't contain names.
module Nameless (A : Type) : Type :=

  anonymize : (∇ α : N. A) -> A
  
  anonymize-postinv : (x : A) -> anonymize (unanonymize x) = x
  anonymize-preinv  : (x : ∇ α : N. A) -> unanonymize (anonymize x) = x

  path : (∇ α : N. A) = A :=
    ua anonymize unanonymize anonymize-preinv anonymize-postinv

end Nameless

// Booleans are nameless because they're either true or false - names nowhere
// to be found.
module Nameless-Bool : Nameless Bool :=

  // A boolean that can contain a name... doesn't really contain any names.
  f {A : Type} : ∇ α : A. Bool -> Bool :=
  | ν α. tt => tt
  | ν α. ff => ff

  // We can pretend we use a name when we don't.
  g {A : Type} : Bool -> ∇ α : A. Bool :=
    fun b : Bool => ν α : A. b

  // The above functions are inverses of each other.
  fg {A : Type} : (x : ∇ α : A. Bool) -> g (f x) = x :=
  | ν α. tt  => refl // We have ``g (f (ν α. tt)) => g tt => ν α. tt``
  | ν α. ff  => refl // We have ``g (f (ν α. ff)) => g ff => ν α. ff``

  gf {A : Type} : (y : Bool) -> f (g y) = y :=
  | tt => refl // We have ``f (g tt) => f (ν α. tt) => tt``
  | ff => refl // We have ``f (g ff) => f (ν α. ff) => ff``

  // Bool is a nameless type.
  Nameless-Bool : Nameless Bool :=
    fun X : Type => ua f g fg gf

end Nameless-Bool

module Nameless-Nat : Nameless Nat :=

  anonymize : (∇ α : A. Nat) -> Nat
  | ν α. z         => z
  | ν α. s (n @ α) => s (anonymize n)

  anonymize-postinv : (n : Nat) -> anonymize (unanoymize n) = n
  | z    => refl
  | s n' => ap s (anonymize-postinv n')

  anonymize-preinv : (n : ∇ α : N. Nat) -> unanonymize (anonymize n) = n
  | ν α. z          => refl
  | ν α. s (n' @ α) => fun i : I => ν α. s (anonymize-preinv n' i @ α)

end Nameless-Nat

// It's easy to see that all finite enumerations are also nameless. We're lazy,
// so we'll just declare the appropriate axioms.
module Nameless-Empty

  f : (∇ α : A. Empty) -> Empty :=
    fun e => match e with end
  
  g : Empty -> (∇ α : A. Empty) :=
    fun e => match e with end

end Nameless-Empty

axiom Nameless-Unit  : Nameless Unit

// It should also be the case that products and sums of nameless types are
// nameless.
module Nameless-Prod {A B : Type} (NA : Nameless A) (NB : Nameless B) : Nameless (A * B)

  f : (∇ α : N. A * B) -> A * B
  | ν α. (x @ a, y @ α) => (anonymize x, anonymize y)

end

axiom Nameless-Sum {A B : Type} (NA : Nameless A) (NB : Nameless B) : Nameless (A + B)

module Nameless-List

  f {NA : Nameless A} : (∇ α : N. List A) -> List A
  | ν α. [] => []
  | ν α. (h @ α) :: (t @ α) => anonymize h :: f t

  g : List A -> ∇ α : N. List A :=
    fun l => ν α. l

  fg {NA : Nameless A} : (l : ∇ α : N. List A) -> g (f l) = l
  | ν α. [] => refl
  | ν α. (h @ α) :: (t @ α) =>
    let
      ν α.
      Ht : f t = t @ a := ap (@ α) (fg t)

      // ν α. anonymize h :: f t = ν α. (h @ α) :: (t @ α)

end Nameless-List

// Is the universe nameless? I don't know! Because we can't match on types,
// there's no way to do anything. Also. it's very interesting to ponder what
// is the semantics of the type Name Type.
%Fail
f : ∇ α : Type. Type -> Type := ?

// BEWARE: the proof below is incorrect.
// f γ @ γ is illegal, because γ is not free in f γ.
// f x @ x is illegal because x is a name and not a name variable.
// @ is ok only when LHS is a term in whcih the RHS is free
Name-not-Nameless (A : Type) : Nameless (Name A) -> Empty :=
  fun H : (X : Type) -> (∇ α : X. Name A) = Name A =>
    let
      // Because (∇ α : X. Name A) = Name A, there must also be a surjection
      // going from right to left.
      f : Name A -> ∇ α : Name A. Name A := ...

      Cantor : ∇ α β : Name A. Empty := ν α. ν β.
        let
          y : ∇ γ : Name A. Name A := ν γ.
            match f γ @ γ with
            | α => β
            | β => α
            | δ => α // Default case

          // f is surjective, so there's an x that gets sent to y.
          x : Name := ...
          H : f x = y
          
          // But then we can concretize both sides of H with x.
          // (Or can we? Wasn't there something in the rules that forbids this step?)
          H' : f x @ x = y @ x := ap (@ x) H 
          
          // After some computation, the type of H' looks like this:
          H' :
            f x @ x =
            match f x @ x with
            | α => β
            | β => α
            | δ => α
        in
          // But now we can derive a contradiction
          match f x @ x with
          | α => abort H' // H' : α = β but they can't be equal because both are fresh.
          | β => abort H' // Η' : β = α but they can't be equal because both are fresh.
          | δ => abort H' // Default case. Η' : δ = α but they can't be equal because f x @ x didn't match α on the left.
    in
      match Cantor with
        // No cases are possible, because Cantor is some names followed with a
        // proof of Empty.
      end
