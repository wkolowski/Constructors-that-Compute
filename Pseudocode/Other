data Z : Type :=
  | (_, _) : nat -> nat -> Z :=
    | (S n) (S m) => (n, m)

// A different definition of integers, more akin to the classical one in which
// an integer k is represented by a pair (n, m) such that n - m = k. This one
// is better, however, because we don't need any complicated quotients or
// higher inductive types - the constructor just computes a normal form for the
// the pair (n, m).

// We use overlapping and order independent patterns.

z : Z := (0, 0)

s : Z -> Z :=
| (n, m) => (S n, m)

p : Z -> Z :=
| (n, m) => (n, S m)

abs : Z -> Z :=
| (n, 0) => (n, 0)
| (0, m) => (m, 0)

// We don't need to match on (S _, S _) because it's not a canonical form.

neg : Z -> Z :=
| (n, m) => (m, n)

add : Z -> Z -> Z :=
| (n1, m1) (n2, m2) => (n1 + n2, m1 + m2)

sub : Z -> Z -> Z :=
| k l => add k (neg l)

sub-spec : (k l : Z) -> sub k l = add k (neg l) :=
| k l => refl

abs-neg : (k : Z) -> abs (neg k) = abs k :=
| (n, 0) => refl
| (0, m) => refl

// LHS: `abs (neg (n, 0)) => abs (0, n) => (n, 0)`, RHS: `abs (n, 0) => (n, 0)`
// LHS: `abs (neg (0, m)) => abs (m, 0) => (m, 0)`, RHS: `abs (0, m) => (m, 0)`

add-assoc : (k l m : Z) -> add (add k l) m = add k (add l m) :=
| (n1, m1) (n2, m2) (n3, m3) i =>
    (Nat.add-assoc n1 n2 n3 i, Nat.add-assoc m1 m2 m3 i)


add-z : (k : Z) -> add k z = k :=
| (n, 0) => refl
| (0, m) => refl

// A type of integers modulo 2...
data Z2 : Type :=
  | z : Z2
  | s : Z2 -> Z2 :=
    | s k => k

// Also integers mod 2, but an alternative implementation.
data Z2' : Type :=
  | in : nat -> Z2' :=
    | S (S n) => in n

// Integers mod n in general?

data Zmod (n : nat) : Type :=
  | in : nat -> Zmod n :=
    | in k => if k <? n then canonical else in (mod k n)

// Native integers mod n?
data Zmod' (n : nat) : Type :=
  | z : Zmod' (S n)
  | s : Zmod' n -> Zmod' (S n) :=
    | looks like this doesn't work

// Lists of natural numbers without consecutive repetitions.

data WList : Type :=
  | wnil : WList
  | wcons : nat -> WList -> WList :=
    | n (wcons m w) =>
        if n =? m then wcons m w else canonical

// Here the keyword `canonical` denotes that in the given case the constructor
// does not compute.
// So we have `wcons 0 (wcons 0 wnil) => wcons 0 wnil` but
// `wcons 1 (wcons 0 (wcons 1 wnil))` is in canonical form.

data UList : Type :=
  | unil : UList
  | ucons : nat -> UList -> UList :=
    | n w => if elem n w then w else canonical

with
elem : nat -> UList -> bool :=
| _ unil => false
| n (ucons m u) => n =? m || elem n u

// We have `ucons 5 (ucons 0 (ucons 5 unil)) => ucons 0 (ucons 5 nil)`.
