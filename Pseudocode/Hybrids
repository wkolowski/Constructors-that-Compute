data Set (A : Type) : Type :=
  | in (x : A)
  | e
  | op (s1 s2 : Set A) :=
    | e y => y
    | x e => x
    | (op x y) z => op x (op y z)
  | comm (x y : Set A) (i : I) :=
    | x y i0 => op x y
    | x y i1 => op y x
  | idem (x : Set A) (i : I) :=
    | x i0 => op x x
    | x i1 => x

// Sets again, but modular
data NETree (A : Type) : Type :=
  | in : A -> FM A
  | op : FM A -> FM A -> FM A :=

// Or not... boils down to the problem of extensible data types.

data Path {A : I -> Type} : A i0 -> A i1 -> Type :=
  | path : (i : I) (x : A i0) (y : A i1) :=
    | i0 x y => x
    | i1 x y => y
  
data SetTrunc (A : Type) : Type :=
  | in : A -> SetTrunc A
  | isSet : forall (x y : A) (p q : x = y), p = q
  | isSet {x y : A} (p q : x = y) (i : I)
  
data FG (A : Type) : Type :=
  | i (x : A)
  | e
  | op : (x y : FG A) :=
    | e y => y
    | x e => x
    | op (op x y) z => op x (op y z)
  | inv (x : FG A) :=
    | inv e => e
    | inv (inv x) => x
    | inv (op x y) => op (inv y) (inv x)
  | invl (x : FG A) (i : I) :=
    | x i0 => op (inv x) x
    | x i1 => e
  | invr (x : FG A) (i : I) :=
    | x i0 => op x (inv x)
    | x i1 => e

// TODO: check
// New, more Haskelly syntax!
//map (f : a -> b) : FG a -> FG b
map {A B : Type} (f : A -> B) : FG A -> FG B :=
| i a      => i (f a)
| e        => e
| op x y   => op (map x) (map y)
| inv x    => inv (map x)
| invl x i => invl (map x) i // ?
| invr x i => invr (map x) i // ?

rev {A : Type} : FG A -> FG A :=
| i a      => i a
| e        => e
| op x y   => op (rev y) (rev x)
| inv x    => inv (rev x)
| invl x i => invl (rev x) i
| invr x i => invr (rev x) i

filter {A : Type} (p : A -> Bool) : FG A -> FG A :=
| i a      => if p a then i a else e
| e        => e
| op x y   => op (filter x) (filter y)
| inv x    => inv (filter x)
| invl x i => invl (filter x) i
| invr x i => invr (filter x) i