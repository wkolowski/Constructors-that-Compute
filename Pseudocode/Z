data Z : Type :=
  | z : Z
  | s : Z -> Z :=
    | p k => k
  | p : Z -> Z :=
    | s k => k

// This the type of integers, defined in a manner similar to the type of
// natural numbers. We have three constructors: `z`, `s` and `p`, but the type
// `Z` is not freely generated by them. There are some additional definitional 
// equalities, which stem from computations performed by the constructors.

// The computation rule for `s` says that `s (p k)` reduces to `k`. We indicate
// this by following the constructor `s` with the symbol `:=` and stating the
// computation rule in the next line using the same syntax as for ordinary
// definitions by pattern matching.

// Note that `| p k => k` means that `s (p k)` computes to `k`, not that `p k`
// computes to `k` - we don't write the function name when pattern matching.
// When discussing computation in the text, we will indicate it with the symbol
// `=>`. For example the computation performed by `s` can be written inline as
// `s (p k) => k`.

// There is also a similar computation rule for the `p` constructor. Together
// these additional rules ensure that the only canonical forms of type `Z` are
// `z`, a finite number of applications of `s` to a `z` at the end, and finite
// number of `p`s applied to `z`. Expressions like `s (p _)` and `p (s _)` are
// not canonical forms.

abs : Z -> Z :=
| z   => z
| s k => s k
| p k => s (abs k)

// This is how we can compute the absolute value of an integer (with the result
// also being an integer, not a natural number). If the input is zero, then the
// result is also zero. If the input is `s k`, then our number is positive, so
// its absolute value is equal to itself. If the input is `p k`, then we know
// the number is negative, so we have to recursively flip all the `p` into `s`.

abs-abs : (k : Z) -> abs (abs k) = abs k :=
| z   => refl
| s k => refl
| p k => refl

// A well-behaved absolute value should obviously be idempotent. This is indeed
// the case and the proof of this fact is very easy - it holds by case analysis
// and computation.

// The `z` case is trivial (`refl` stands for reflexivity - `refl x : x = x`).

// In the `s` case, we have `abs (abs (s k)) => abs (s k) = s k` on the LHS and
// `abs (s k) => s k` on the RHS, so `refl` suffices.

// In the `p` case, we have `abs (abs (p k)) => abs (s (abs k)) => s (abs k)`
// on the LHS and `abs (p k) => s (abs k)` on the RHS, so `refl` suffices.

// Note that the triviality of this proof is NOT caused by the computation
// rules we attached to constructors. The proof would go through in the same
// way if `Z` didn't have them.

neg : Z -> Z :=
| z   => z
| s k => p (neg k)
| p k => s (neg k)

add : Z -> Z -> Z :=
| z     l => l
| (s k) l => s (add k l)
| (p k) l => p (add k l)

sub : Z -> Z -> Z :=
| k z     => k
| k (s l) => p (sub k l)
| k (p l) => s (sub k l)

// The definitions of negation, addition and subtraction are straightforward
// and extremely natural in comparison with the various definitions of integer
// functions from Coq's standard library.

// Negation is defined by flipping all `s` to `p` and all `p` to `s`.

// Addition is analogous to addition of naturals, but with the additional case
// for the `p` constructor.

// The definition of subtraction is the mirror image of that of addition - what
// a beautiful symmetry!

sub-spec : (k l : Z) -> sub k l = add (neg l) k :=
| k z     => refl
| k (s l) => ap p (sub-spec k l)
| k (p l) => ap s (sub-spec k l)

// TODO

// Absolute value of negation.
abs-neg : (k : Z) -> abs (neg k) = abs k :=
| z        => refl
| s z      => refl
| s (s k') => ap s (abs-neg (s k'))
| p z      => refl
| p (p k') => ap s (abs-neg (p k'))

// LHS: `abs (neg (s (s k'))) => abs (p (neg (s k'))) => s (abs (neg (s k')))`
// RHS: `abs (s (s k')) => s (abs (s k'))`
// So the goal is convertible with `s (abs (neg (s k'))) = s (abs (s k'))`.
// From the recursive call we have `abs-neg (s k') : abs (neg (s k')) = abs (s k')`.
// So it suffices to apply `s` on both sides of the equation.

// TODO Note that a simple recursive call // LHS: abs (neg (s k')) = s (abs (neg k'))
// TODO abs (s k') = s k'

// Some more theorems!

add-assoc : (k l m : Z) -> add (add k l) m = add k (add l m) :=
| z      l m => refl
| (s k') l m => ap s (add-assoc k' l m)
| (p k') l m => ap p (add-assoc k' l m)

add-z : (k : Z) -> add k z = k :=
| z    => refl
| s k' => ap s (add-z k')
| p k' => ap p (add-z k')

add-s : (k l : Z) -> add k (s l) = s (add k l) :=
| z      l => refl
| (s k') l => ap s (add-s k' l)
| (p k') l => ap p (add-s k' l)

// LHS: `add (p k') (s l) => p (add k' (s l))`
// RHS: `s (add (p k') l) => s (p (add k' l)) => add k' l
// Goal : p (add k' (s l)) = add k' l
// add-s k' l : add k' (s l) = s (add k' l)
// ap p (add-s k' l) : p (add k' (s l)) = add k' l

add-p : (k l : Z) -> add k (p l) = p (add k l) :=
| z      l => refl
| (s k') l => ap s (add-p k' l)
| (p k') l => ap p (add-p k' l)

// Let's make our lives easier with overlapping patterns for the next one.
add : Z -> Z -> Z :=
| z     l      => l
| (s k) l      => s (add k l)
| (p k) l      => p (add k l)
| k     z      => k
| k     (s l') => s (add k l')
| k     (p l') => p (add k l')

add-comm : (k l : Z) -> add k l = add l k :=
| z      l => refl
| (s k') l => ap s (add-comm k' l)
| (p l') l => ap p (add-comm k' l)

sub : Z -> Z -> Z :=
| k      z       => k
| k      (s l') => p (sub k l')
| k      (p l') => s (sub k l')
| (s k') l      => s (sub k' l)
| (p k') l      => p (sub l' l)


sub-diag : (k : Z) -> sub k k = z :=
| z    => refl
| s k' => sub-diag k'
| p k' => sub-diag k'

 // `sub (s k') (s k') => p (sub (S k') k') => p (s (sub k' k')) => sub k' k'`
          // `sub (s k') (s k') => s (sub k' (s k')) => s (p (sub k' k') => sub k' k'`
          
sub-add : (k l m : Z) -> sub k (add l m) = sub (sub k l) m :=
| k z      m => refl
| k (s l') m => ap p (sub-add k l' m) // LHS: `sub k (add (s l') m) => sub k (s (add l' m)) => p (sub k (add l' m))`
			  	      // RHS: `sub (sub k (s l')) m => sub (p (sub k l')) m => p (sub (sub k l') m)`
| k (p l') m => ap s (sub-add k l' m) // LHS: `sub k (add (p l') m) => sub k (p (add l' m)) => s (sub k (add l' m))`
				      // RHS: `sub (sub k (p l')) m => sub (s (sub k l')) m => s (sub (sub k l') m)`


// More functions.
zeq : Z -> Z -> Bool :=
| z      z      => true
| (s k') (s l') => zeq k' l'
| (p k') (p l') => zeq k' l'
| _      _      => false

zeq-neg : (k l : Z) -> zeq (neg k) (neg l) = zeq k l :=
| z      z      => refl
| (s k') (s l') => zeq-neg k' l' // `zeq (neg (s k')) (neg (s l')) => zeq (p (neg k')) (p (neg l')) => zeq (neg k') (neg l')`
| (p k') (p l') => zeq-neg k' l'
| _      _      => refl
