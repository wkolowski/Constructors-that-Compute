// This is supposed to be the type of integers.
data Z : Type :=
  | z : Z
  | s : Z -> Z :=
    | p k => k
  | p : Z -> Z :=
    | s k => k

// We have three constructors: `z`, `s` and `p`, but the type `Z` is not freely
// generated by them. There are some additional definitional equalities, which
// stem from computations performed by the constructors. The computation rules
// for `s` says that `s (p k)` computes to `k` (we will write this inline in
// the text as `s (p k) => k`, with the arrow => indicating computation). There
// is also a similar computation rule for the `p` constructor. Together these
// additional rules ensure that the only canonical forms of type `Z` are `z`,
// finite strings of `s` that end with a `z` and finite strings of `p` that end
// with a 'z'.

// Also integers, but differently.
data Z' : Type :=
  | (_, _) : nat -> nat -> Z' :=
    | (S n) (S m) => (n, m)

// The type of free monoids on type A. 
data FM (A : Type) : Type :=
  | e : FM A
  | in : A -> FM A
  | op : FM A -> FM A -> FM A :=
    | e y        => y
    | (op x y) z => op x (op y z)
    | x e        => x

// Absolute value on integers.
abs : Z -> Z :=
| z   => z
| s k => s k
| p k => s (abs k)

// Absolute value is idempotent.
abs-abs : (k : Z) -> abs (abs k) = abs k :=
| z   => refl
| s k => refl
| p k => refl

// The `z` case is trivial.

// In the `s` case, we have `abs (abs (s k)) => abs (s k) = s k` on the LHS and
// `abs (s k) => s k` on the RHS, so `refl` suffices.

// In the `p` case, we have `abs (abs (p k)) => abs (s (abs k)) => s (abs k)`
// on the LHS and `abs (p k) => s (abs k)` on the RHS, so `refl` suffices.

// Negation.
neg : Z -> Z :=
| z   => z
| s k => p (neg k)
| p k => s (neg k)

// Addition.
add : Z -> Z -> Z :=
| z l     => l
| (s k) l => s (add k l)
| (p k) l => p (add k l)

// Subtraction.
sub : Z -> Z -> Z :=
| k z     => k
| k (s l) => p (sub k l)
| k (p l) => s (sub k l)

// Subtraction is exactly what we expect.
sub-spec : (k l : Z) -> sub k l = add (neg l) k :=
| k z     => refl
| k (s l) => ap p (sub-spec k l)
| k (p l) => ap s (sub-spec k l)

// Absolute value of negation.
abs-neg : (k : Z) -> abs (neg k) = abs k :=
| z        => refl
| s z      => refl
| s (s k') => ap s (abs-neg (s k'))
| p z      => refl
| p (p k') => ap s (abs-neg (p k'))

// LHS: `abs (neg (s (s k'))) => abs (p (neg (s k'))) => s (abs (neg (s k')))`
// RHS: `abs (s (s k')) => s (abs (s k'))`
// So the goal is convertible with `s (abs (neg (s k'))) = s (abs (s k'))`.
// From the recursive call we have `abs-neg (s k') : abs (neg (s k')) = abs (s k')`.
// So it suffices to apply `s` on both sides of the equation.

// TODO Note that a simple recursive call // LHS: abs (neg (s k')) = s (abs (neg k'))
// TODO abs (s k') = s k'

// Convert a free monoid expression to a list.
f : {A : Type} -> FM A -> list A :=
| e      => []
| in a   => [a]
| op x y => f x ++ f y

// Convert a list to a free monoid expression.
g : {A : Type} -> list A -> FM A :=
| []     => e
| h :: t => op (in h) (g t)

fg : {A : Type} (x : FM A) -> g (f x) = x :=
| e           => refl
| in a        => refl
| op (in a) y => ap (op (in a)) (fg y)

// The `e` and `in a` cases are trivial.
// In the `op (in a) y` case:

// Note that we don't need to match the cases `op e _` or `op (op _ _) _` because
// they are not canonical forms of FM A. This is because they get computed away
// by the constructor `op`. So it suffices to consider `op (in a) y`.

// LHS: g (f (op (in a) y)) => g (f (in a) ++ f y) => g ([a] ++ f y) => g (a :: f y) => op (in a) (g (f y))
// RHS: op (in a) y

// So the goal is convertible with `op (in a) (g (f y)) = op (in a) y`.
// The recursive call tives us `fg y : g (f y) = y`.
// It suffices to prepend `op (in a)` on both sides of the equation.

gf : {A : Type} (l : list A) -> f (g l) = l :=
| []     => refl
| h :: t => ap (h ::) (gf t)

// The `[]` case is trivial.
// In the `h :: t` case:

// LHS: `f (g (h :: t)) => f (op (in h) (g t)) => f (in h) ++ f (g t) => [h] ++ f (g t) => h :: f (g t)`
// RHS: `h :: t`

// So the goal is convertible with `h :: f (g t) = h :: t`.
// The recursive call gives us `gf t : f (g t) = t`.
// It suffices to prepend `h ::` on both sides of the equation.

list-is-free-mon : (A : Type) -> FM A = list A :=
  ... // by univalence, as (f, g, fg, gf) is an equivalence

// It is not possible to define the free group with this approach, because we
// encounter non-linear patterns when trying to enforce x(x^-1) = e.

// | op : FG A -> FG A -> FG A with
//   | op x (inv x) => e

// A type of integers modulo 2...
data Z2 : Type :=
  | z : Z2
  | s : Z2 -> Z2 :=
    | s k => k

// Also integers mod 2, but an alternative implementation.
data Z2' : Type :=
  | in : nat -> Z2' :=
    | S (S n) => in n

// Lists of natural numbers without consecutive repetitions.

data WList : Type :=
  | wnil : WList
  | wcons : nat -> WList -> WList :=
    | n (wcons m w) =>
        if n =? m then wcons m w else canonical

// Here the keyword `canonical` denotes that in the given case the constructor
// does not compute.
// So we have `wcons 0 (wcons 0 wnil) => wcons 0 wnil` but
// `wcons 1 (wcons 0 (wcons 1 wnil))` is in canonical form.

data UList : Type :=
  | unil : UList
  | ucons : nat -> UList -> UList :=
    | n w => if elem n w then w else canonical

with
elem : nat -> UList -> bool :=
| _ unil => false
| n (ucons m u) => n =? m || elem n u

// We have `ucons 5 (ucons 0 (ucons 5 unil)) => ucons 0 (ucons 5 nil)`.
