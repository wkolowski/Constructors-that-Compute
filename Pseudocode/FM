// The type of free monoids on type A. 
data FM (A : Type) : Type :=
  | e : FM A
  | in : A -> FM A
  | op : FM A -> FM A -> FM A :=
    | e y        => y
    | (op x y) z => op x (op y z)
    | x e        => x

// Convert a free monoid expression to a list.
f : {A : Type} -> FM A -> list A :=
| e      => []
| in a   => [a]
| op x y => f x ++ f y

// Convert a list to a free monoid expression.
g : {A : Type} -> list A -> FM A :=
| []     => e
| h :: t => op (in h) (g t)

fg : {A : Type} (x : FM A) -> g (f x) = x :=
| e           => refl
| in a        => refl
| op (in a) y => ap (op (in a)) (fg y)

// The `e` and `in a` cases are trivial.
// In the `op (in a) y` case:

// Note that we don't need to match the cases `op e _` or `op (op _ _) _` because
// they are not canonical forms of FM A. This is because they get computed away
// by the constructor `op`. So it suffices to consider `op (in a) y`.

// LHS: g (f (op (in a) y)) => g (f (in a) ++ f y) => g ([a] ++ f y) => g (a :: f y) => op (in a) (g (f y))
// RHS: op (in a) y

// So the goal is convertible with `op (in a) (g (f y)) = op (in a) y`.
// The recursive call tives us `fg y : g (f y) = y`.
// It suffices to prepend `op (in a)` on both sides of the equation.

gf : {A : Type} (l : list A) -> f (g l) = l :=
| []     => refl
| h :: t => ap (h ::) (gf t)

// The `[]` case is trivial.
// In the `h :: t` case:

// LHS: `f (g (h :: t)) => f (op (in h) (g t)) => f (in h) ++ f (g t) => [h] ++ f (g t) => h :: f (g t)`
// RHS: `h :: t`

// So the goal is convertible with `h :: f (g t) = h :: t`.
// The recursive call gives us `gf t : f (g t) = t`.
// It suffices to prepend `h ::` on both sides of the equation.

list-is-free-mon : (A : Type) -> FM A = list A :=
  ... // by univalence, as (f, g, fg, gf) is an equivalence

// It is not possible to define the free group with this approach, because we
// encounter non-linear patterns when trying to enforce x(x^-1) = e.

// | op : FG A -> FG A -> FG A with
//   | op x (inv x) => e

map {A B : Type} (f : A -> B) : FM A -> FM B :=
| e      => e
| in a   => in (f a)
| op x y => op (map x) (map y)

map-id {A : Type} : (x : FM A) -> map id x = x :=
| e      => refl
| in a   => refl
| op x y => fun i : I => op (map-id x i) (map-id y i)

map-map {A B C : Type} (f : A -> B) (g : B -> C) : (x : FM A) -> map g (map f x) = map (f.g) x :=
| e      => refl
| in a   => refl
| op x y => fun i : I => op (map-map x i) (map-map y i)

filter {A : Type} (p : A -> Bool) : FM A -> FM A :=
| e      => e
| in a   => if p a then in a else e
| op x y => op (filter x) (filter y)

filter-filter {A : Type} (p : A -> Bool) : (x : FM A) -> filter p (filter p x) = filter p x :=
| e      => refl
| in a   => if p a then refl else refl
| op x y => fun i : I => op (filter-filter x i) (filter-filter y i)

rev {A : Type} : FM A -> FM A :=
| e      => e
| in a   => in a
| op x y => op (rev y) (rev x)

rev-rev {A : Type} : (x : FM A) -> rev (rev x) = x
| e      => refl
| in a   => refl
| op x y => fun i : I => op (rev-rev x i) (rev-rev y i)

map-rev {A B : Type} (f : A -> B) : (x : FM A) -> map f (rev x) = rev (map f x) :=
| e      => refl
| in a   => refl
| op x y => fun i : I => op (map-rev y i) (map-rev x i)

rev-filter {A : Type} (p : A -> Bool) : (x : FM A) -> rev (filter p x) = filter p (rev x) :=
| e      => refl
| in a   => if p a then refl else refl
| op x y => fun i : I => op (rev-filter y i) (rev-filter x i)

join {A : Type} : FM (FM A) -> FM A :=
| e      => e
| in fma => fma
| op x y => op (join x) (join y)

bind {A B : Type} (f : A -> FM B) : FM A -> FM B :=
| e      => e
| in a   => f a
| op x y => op (bind x) (bind y)

pure {A : Type} : A -> FM A := in

bind-pure-l {A : Type} : (x : FM A) -> bind pure x = x :=
| e      => refl
| in a   => refl
| op x y => fun i : I => op (bind-pure-l x i) (bind-pure-l y i)

bind-pure-r {A B : Type} (f : A -> FM B) : (a : A) -> bind f (pure a) = f a := refl

bind-bind {A B C : Type} (f : A -> FM B) (g : B -> FM C)
		: (x : FM A) -> bind g (bind f x) = bind (fun a : A => bind g (f a)) x :=
| e      => refl
| in a   => refl
| op x y => fun i : I => op (bind-bind f g x i) (bind-bind f g y i)
