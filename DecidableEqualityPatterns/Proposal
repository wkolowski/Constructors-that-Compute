// Idea: non-linear patterns for types that have decidable equality.

// For example, the function below removes adjacent duplicates from a list
// provided that the type of elements in the list has decidable equality.
dedupConsecutive {A : EqType} : List A -> List A
| [] => []
| h :: h :: t => dedupConsecutive (h :: t)
| h :: t => h :: dedupConsecutive t

// This definition would be translated by the compiler (at an early stage)
// into something like this:
dedupConsecutive {A : EqType} : List A -> List A
| [] => []
| x :: y :: t => if x =? y then dedupConsecutive (y :: t) else x :: dedupConsecutive t

// Or maybe even a more Haskell-like version.
dedupConsecutive {A : EqType} : List A -> List A
| [] => []
| x :: y :: t | x =? y    => dedupConsecutive (y :: t)
              | otherwise => x :: dedupConsecutive t

// Note that the semantics of the non-linear matches are the classical first-match
// semantics and it looks like it'd be hard to transplant this into the setting
// of overlapping and order-independent patterns.

// Would such non-linear patterns even be useful? Probably not, and they would
// introduce some complications into the proofs, but they would be implemented
// anyway as part of supporting the nominal inductive types.